<!DOCTYPE html>
<html lang="es">
<head>
<link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1e40af">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Inspector PCB</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { margin: 0; padding: 0; overflow: hidden; font-family: system-ui, -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        
        /* Animación para el efecto "pulse" en nuevos botones */
        @keyframes pulse-new {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 0, 0); }
        }
        .animate-pulse-new {
            animation: pulse-new 1s ease-out 3;
        }

    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        window.storage = {
            async get(key) {
                const value = localStorage.getItem(key);
                return value ? { key, value } : null;
            },
            async set(key, value) {
                localStorage.setItem(key, value);
                return { key, value };
            },
            async delete(key) {
                localStorage.removeItem(key);
                return { key, deleted: true };
            },
            async list(prefix) {
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (!prefix || key.startsWith(prefix)) {
                        keys.push(key);
                    }
                }
                return { keys };
            }
        };

        const { useState, useEffect, useRef } = React;
        
        const PCBDefectInspector = () => {
          const [models, setModels] = useState([]);
          const [currentModel, setCurrentModel] = useState(null);
          const [view, setView] = useState('select');
          const [buttons, setButtons] = useState([]);
          
          // { modelId: { buttonId: [{type: 'faltante', timestamp: 123, puesto: 'A1'}] } }
          const [defects, setDefects] = useState({}); 
          
          const [selectedButton, setSelectedButton] = useState(null);
          const [showDefectMenu, setShowDefectMenu] = useState(false);
          // menuPosition es la posición central del botón en coordenadas de pantalla
          const [menuPosition, setMenuPosition] = useState({ x: 0, y: 0, width: 0, height: 0 }); 
          const [showNameDialog, setShowNameDialog] = useState(false);
          const [tempImage, setTempImage] = useState(null);
          const [modelNameInput, setModelNameInput] = useState('');
          const [showAddButton, setShowAddButton] = useState(false);
          const [newButtonName, setNewButtonName] = useState('');
          const [editingButton, setEditingButton] = useState(null);
          const [showEditDialog, setShowEditDialog] = useState(false);
          const [editForm, setEditForm] = useState({ width: 50, height: 30 });
          const [isDragging, setIsDragging] = useState(false);
          const [draggedButton, setDraggedButton] = useState(null);
          const [showSidebar, setShowSidebar] = useState(false);
          const [isEditMode, setIsEditMode] = useState(false);
          
          const [puesto, setPuesto] = useState('');
          const [puestoInput, setPuestoInput] = useState('');
          const [showStationDialog, setShowStationDialog] = useState(false);
          
          // Nuevo estado para el diálogo de sector
          const [showSectorDialog, setShowSectorDialog] = useState(false);
          const [tempButtonData, setTempButtonData] = useState(null);

          // Nuevo estado para el efecto de pulso
          const [pulsingButtonId, setPulsingButtonId] = useState(null);

          const imageRef = useRef(null);
          const containerRef = useRef(null);
          
          // Definición de tipos de defectos (centralizado)
          const defectTypes = {
              'faltante': { name: 'Faltante', color: 'bg-red-600', short: 'F' },
              'levantado': { name: 'Levantado', color: 'bg-orange-600', short: 'L' },
              'mal_insertado': { name: 'Mal insertado', color: 'bg-pink-600', short: 'MI' }, 
              'equivocado': { name: 'Equivocado', color: 'bg-indigo-600', short: 'E' },     
          };

          // INICIALIZACIÓN Y CARGA DE DATOS
          useEffect(() => {
            loadData();
          }, []);
          
          useEffect(() => {
              if (puesto === null) {
                  setShowStationDialog(true);
              }
          }, [puesto]);


          useEffect(() => {
            if (models.length > 0 || buttons.length > 0 || Object.keys(defects).length > 0 || puesto) {
              saveData();
            }
          }, [models, buttons, defects, currentModel, puesto]);

          const loadData = async () => {
            try {
              const modelsData = await window.storage.get('pcb_models');
              const buttonsData = await window.storage.get('pcb_buttons');
              const defectsData = await window.storage.get('pcb_defects');
              const currentData = await window.storage.get('pcb_current');
              const puestoData = await window.storage.get('pcb_puesto');


              if (modelsData) setModels(JSON.parse(modelsData.value));
              if (buttonsData) setButtons(JSON.parse(buttonsData.value));
              if (defectsData) setDefects(JSON.parse(defectsData.value));
              if (currentData) setCurrentModel(currentData.value);
              
              setPuesto(puestoData ? puestoData.value : null);
              
            } catch (error) {
              console.log('Iniciando con datos nuevos');
            }
          };

          const saveData = async () => {
            try {
              await window.storage.set('pcb_models', JSON.stringify(models));
              await window.storage.set('pcb_buttons', JSON.stringify(buttons));
              await window.storage.set('pcb_defects', JSON.stringify(defects));
              await window.storage.set('pcb_puesto', puesto);
              if (currentModel) {
                await window.storage.set('pcb_current', currentModel);
              }
            } catch (error) {
              console.error('Error al guardar:', error);
            }
          };

          const handleSavePuesto = () => {
              if (!puestoInput.trim()) {
                  alert('Debe ingresar el puesto de inspección.');
                  return;
              }
              setPuesto(puestoInput.trim());
              setShowStationDialog(false);
          }


          const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (event) => {
                setTempImage(event.target.result);
                setShowNameDialog(true);
              };
              reader.readAsDataURL(file);
            }
          };

          const saveModel = () => {
            if (!modelNameInput.trim()) {
              alert('Por favor ingrese un nombre para la placa');
              return;
            }
            
            const newModel = {
              id: Date.now().toString(),
              name: modelNameInput.trim(),
              image: tempImage
            };
            setModels([...models, newModel]);
            setShowNameDialog(false);
            setModelNameInput('');
            setTempImage(null);
          };

          const selectModel = (modelId) => {
            setCurrentModel(modelId);
            setView('inspect');
            if (!defects[modelId]) {
              setDefects({ ...defects, [modelId]: {} });
            }
          };

          const getCurrentModelButtons = () => {
            return buttons.filter(b => b.modelId === currentModel);
          };

          const getCurrentModel = () => {
            return models.find(m => m.id === currentModel);
          };

          // FUNCIÓN DE CONTEO
          const getButtonDefectCount = (buttonId) => {
            const modelDefects = defects[currentModel] || {};
            const buttonDefectList = modelDefects[buttonId] || [];

            const counts = {
              faltante: 0,
              levantado: 0,
              mal_insertado: 0,
              equivocado: 0,
            };

            buttonDefectList.forEach(defect => {
              if (counts.hasOwnProperty(defect.type)) {
                counts[defect.type] += 1;
              }
            });

            return {
              ...counts,
              total: buttonDefectList.length
            };
          };

          const getSortedButtons = () => {
            return getCurrentModelButtons()
              .map(button => ({
                ...button,
                ...getButtonDefectCount(button.id)
              }))
              .sort((a, b) => b.total - a.total);
          };

          // LÓGICA DE INTERACCIÓN
          const handleButtonClick = (button, e) => {
            e.stopPropagation();
            
            if (isDragging) return;

            if (isEditMode) {
                setEditingButton(button);
                setEditForm({
                  width: button.width || 50,
                  height: button.height || 30
                });
                setShowEditDialog(true);
                return;
            }
            
            // MODO INSPECCIÓN: Click/Tap abre el menú de defectos
            const rect = e.currentTarget.getBoundingClientRect();
            setSelectedButton(button);
            // Guardar posición, ancho y alto para el cálculo de límites del menú
            setMenuPosition({
              x: rect.left,
              y: rect.top,
              width: rect.width,
              height: rect.height,
            });
            setShowDefectMenu(true);
          };
          
          const getPositionOnImage = (clientX, clientY) => {
            if (!imageRef.current) return null;
            
            const imgRect = imageRef.current.getBoundingClientRect();
            // Los cálculos de posición deben ser relativos al contenedor scrollable,
            // pero la posición de la imagen dentro del contenedor (scroll) debe ser ignorada.
            // Para eso, la posición relativa (%) ya se encarga de la estabilidad.
            // Aquí solo usamos clientX/clientY y el rectángulo de la imagen visible.
            const x = ((clientX - imgRect.left) / imgRect.width) * 100;
            const y = ((clientY - imgRect.top) / imgRect.height) * 100;
            
            return {
              x: Math.max(2, Math.min(98, x)), 
              y: Math.max(2, Math.min(98, y))
            };
          };

          const handleDragStart = (button, e) => {
            if (!isEditMode) return;
            // Solo permitir arrastrar con el botón izquierdo del ratón (e.button === 0) o con toque (e.touches)
            if (e.button !== 0 && !e.touches) return; 

            e.preventDefault(); 
            e.stopPropagation();
            
            setIsDragging(true);
            setDraggedButton(button.id);
          };

          const handleMove = (clientX, clientY) => {
            if (!isDragging || !draggedButton || !isEditMode) return;
            
            const pos = getPositionOnImage(clientX, clientY);
            if (!pos) return;
            
            setButtons(prevButtons => prevButtons.map(b => 
              b.id === draggedButton ? { ...b, x: pos.x, y: pos.y } : b
            ));
          };
          
          const handleMouseMove = (e) => {
            handleMove(e.clientX, e.clientY);
          };

          const handleTouchMove = (e) => {
            if (e.touches.length !== 1) return;
            e.preventDefault(); // Prevenir el scroll durante el arrastre
            const touch = e.touches[0];
            handleMove(touch.clientX, touch.clientY);
          };

          const handleMouseUp = (e) => {
            if (isDragging && draggedButton) {
              setIsDragging(false);
              setDraggedButton(null);
            }
          };

          // FUNCIÓN DE REGISTRO
          const registerDefect = (type) => {
            if (!puesto) {
                alert('Debe ingresar el puesto de inspección antes de registrar defectos.');
                setShowDefectMenu(false);
                setShowStationDialog(true);
                return;
            }

            const now = new Date();
            
            const newDefect = {
                type: type,
                timestamp: now.getTime(),
                puesto: puesto 
            };
            
            const buttonId = selectedButton.id;
            
            setDefects(prevDefects => {
                const modelDefects = prevDefects[currentModel] || {};
                const buttonDefects = modelDefects[buttonId] || [];

                return {
                    ...prevDefects,
                    [currentModel]: {
                        ...modelDefects,
                        [buttonId]: [...buttonDefects, newDefect]
                    }
                };
            });
            
            setShowDefectMenu(false);
            setSelectedButton(null);
          };
          
          // Abre el diálogo de sector
          const handleOpenSectorDialog = () => {
            if (!newButtonName.trim()) {
              alert('Por favor, ingrese un nombre para el componente.');
              return;
            }
            // Guarda los datos temporalmente
            setTempButtonData({
              id: Date.now().toString(),
              modelId: currentModel,
              name: newButtonName.trim(),
              x: 50,
              y: 50,
              width: 50,
              height: 30,
            });
            setShowSectorDialog(true);
            setShowAddButton(false);
          };
          
          // Crea el botón con el sector seleccionado
          const handleCreateNewButton = (sector) => {
            if (!tempButtonData) return;

            const newButton = {
              ...tempButtonData,
              sector: sector,
            };
            
            setButtons(prevButtons => [...prevButtons, newButton]);
            setNewButtonName('');
            setShowSectorDialog(false);
            setTempButtonData(null);
            
            // 1. Activar efecto 'pulse'
            setPulsingButtonId(newButton.id);
            
            // 2. Activar modo edición automáticamente
            if (!isEditMode) {
                setIsEditMode(true);
                // Notificación simple
                setTimeout(() => alert(`¡Componente "${newButton.name}" (${sector}) creado! Se activó el Modo Edición (botón amarillo) para que puedas arrastrarlo a su posición.`), 100);
            }
            
            // 3. Remover el pulso después de un tiempo
            setTimeout(() => setPulsingButtonId(null), 3000); 
          };

          const deleteButton = (buttonId) => {
            if (confirm('¿Eliminar este componente?')) {
              setButtons(buttons.filter(b => b.id !== buttonId));
              
              setDefects(prevDefects => {
                  const modelDefects = { ...prevDefects[currentModel] };
                  delete modelDefects[buttonId];
                  return {
                      ...prevDefects,
                      [currentModel]: modelDefects
                  };
              });
            }
          };

          const updateButtonStyle = () => {
            setButtons(buttons.map(b => 
              b.id === editingButton.id 
                ? { ...b, width: editForm.width, height: editForm.height }
                : b
            ));
            setShowEditDialog(false);
            setEditingButton(null);
          };
          
          // Se movió la lógica de cambio de sector al diálogo de edición
          const updateButtonSector = (newSector) => {
             setButtons(buttons.map(b => 
              b.id === editingButton.id 
                ? { ...b, sector: newSector }
                : b
            ));
            setEditingButton(prev => ({...prev, sector: newSector})); // Actualizar inmediatamente el estado local del diálogo
          }


          // FUNCIÓN DE EXPORTACIÓN MODIFICADA (a TSV para hoja de cálculo)
          const exportToExcel = () => {
            const model = getCurrentModel();
            const modelDefects = defects[currentModel] || {};
            
            // Usamos \t (tabulador) como separador para que Excel/Sheets lo interprete como columnas
            let tsv = 'Modelo\tComponente\tSector\tDefecto\tPuesto detector\tFecha\tHora\n';
            
            getCurrentModelButtons().forEach(button => {
                const defectList = modelDefects[button.id] || [];
                const buttonSector = button.sector || 'N/A';
                
                defectList.forEach(defect => {
                    const date = new Date(defect.timestamp);
                    // Formato YYYY-MM-DD
                    const fecha = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');
                    // Formato HH:MM:SS
                    const hora = String(date.getHours()).padStart(2, '0') + ':' + String(date.getMinutes()).padStart(2, '0') + ':' + String(date.getSeconds()).padStart(2, '0');

                    // Aseguramos que todos los campos estén en el orden y formato solicitados
                    tsv += `${model.name}\t${button.name}\t${buttonSector}\t${defectTypes[defect.type].name}\t${defect.puesto}\t${fecha}\t${hora}\n`;
                });
            });

            // Usamos 'text/plain' para máxima compatibilidad con TSV, y nombramos el archivo con .xls
            const blob = new Blob([tsv], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `defectos_${model.name}_${new Date().toISOString().split('T')[0]}.xls`; // Usar .xls para abrirlo como hoja de cálculo
            link.click();
          };

          const getDefectColor = (count) => {
            if (count === 0) return 'rgba(0, 200, 0, 0.3)';
            if (count <= 2) return 'rgba(255, 255, 0, 0.5)';
            if (count <= 5) return 'rgba(255, 150, 0, 0.6)';
            return 'rgba(255, 0, 0, 0.8)';
          };
          
          // Iconos
          const Upload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
          const Plus = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>;
          const BarChart3 = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>;
          const Trash2 = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>;
          const Download = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
          const X = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>;
          const Menu = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>;
          const Settings = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
          const Edit = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>;


          // INICIO DE RENDERIZADO DE DIÁLOGOS Y VISTAS

          if (showStationDialog) {
            return (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg p-6 max-w-md w-full">
                  <h2 className="text-2xl font-bold mb-4 text-blue-600">Puesto de Inspección</h2>
                  <p className="mb-4">Por favor, ingrese el nombre o número del puesto de trabajo para garantizar la trazabilidad de las fallas.</p>
                  <input
                    type="text"
                    value={puestoInput}
                    onChange={(e) => setPuestoInput(e.target.value)}
                    placeholder="Ej: Linea A, Puesto 5"
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg mb-4 text-lg"
                    autoFocus
                    onKeyPress={(e) => e.key === 'Enter' && handleSavePuesto()}
                  />
                  <button
                    onClick={handleSavePuesto}
                    className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 font-bold"
                  >
                    Confirmar Puesto
                  </button>
                </div>
              </div>
            );
          }


          if (showNameDialog) {
            return (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg p-6 max-w-md w-full">
                  <h2 className="text-2xl font-bold mb-4">Nombre de la Placa</h2>
                  <div className="mb-4">
                    <img src={tempImage} alt="Preview" className="w-full rounded border-2 border-gray-300 mb-4" />
                  </div>
                  <input
                    type="text"
                    value={modelNameInput}
                    onChange={(e) => setModelNameInput(e.target.value)}
                    placeholder="Ej: PCB-2024-V1"
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg mb-4 text-lg"
                    autoFocus
                    onKeyPress={(e) => e.key === 'Enter' && saveModel()}
                  />
                  <div className="flex gap-2">
                    <button
                      onClick={saveModel}
                      className="flex-1 bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 font-bold"
                    >
                      Guardar
                    </button>
                    <button
                      onClick={() => {
                        setShowNameDialog(false);
                        setModelNameInput('');
                        setTempImage(null);
                      }}
                      className="flex-1 bg-gray-400 text-white py-3 rounded-lg hover:bg-gray-500 font-bold"
                    >
                      Cancelar
                    </button>
                  </div>
                </div>
              </div>
            );
          }
          
          if (showSectorDialog) {
            return (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg p-6 max-w-md w-full">
                  <h2 className="text-2xl font-bold mb-4 text-blue-600">Seleccionar Sector</h2>
                  <p className="mb-4">¿El componente "{tempButtonData.name}" es de inserción **Automática (IA)** o **Manual (IM)**?</p>
                  <div className="grid grid-cols-2 gap-4">
                      <button
                        onClick={() => handleCreateNewButton('IA')}
                        className="py-3 rounded-lg font-bold text-lg bg-blue-600 text-white hover:bg-blue-700"
                      >
                        IA (Automática)
                      </button>
                      <button
                        onClick={() => handleCreateNewButton('IM')}
                        className="py-3 rounded-lg font-bold text-lg bg-purple-600 text-white hover:bg-purple-700"
                      >
                        IM (Manual)
                      </button>
                  </div>
                   <button
                        onClick={() => { setShowSectorDialog(false); setNewButtonName(''); setShowAddButton(true); setTempButtonData(null); }}
                        className="w-full mt-4 py-2 text-gray-600 hover:text-gray-800"
                    >
                        Cancelar
                    </button>
                </div>
              </div>
            );
          }


          if (showEditDialog && editingButton) {
            return (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg p-6 max-w-md w-full">
                  <h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
                    <Edit /> Editar: {editingButton.name}
                  </h2>
                  
                  {/* Edición de Sector */}
                  <div className="mb-4">
                    <label className="block text-sm font-bold mb-2">Sector de Inserción</label>
                    <div className="grid grid-cols-2 gap-2">
                      <button
                        onClick={() => updateButtonSector('IA')}
                        className={`py-2 rounded-lg font-bold text-sm border-2 ${editingButton.sector === 'IA' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-blue-600 border-blue-300 hover:bg-blue-50'}`}
                      >
                        IA (Automática)
                      </button>
                      <button
                        onClick={() => updateButtonSector('IM')}
                        className={`py-2 rounded-lg font-bold text-sm border-2 ${editingButton.sector === 'IM' ? 'bg-purple-600 text-white border-purple-600' : 'bg-white text-purple-600 border-purple-300 hover:bg-purple-50'}`}
                      >
                        IM (Manual)
                      </button>
                    </div>
                  </div>


                  {/* Edición de Tamaño */}
                  <div className="mb-4">
                    <label className="block text-sm font-bold mb-2">Ancho (px)</label>
                    <input
                      type="range"
                      min="30"
                      max="150"
                      value={editForm.width}
                      onChange={(e) => setEditForm({ ...editForm, width: parseInt(e.target.value) })}
                      className="w-full"
                    />
                    <div className="text-center text-gray-600">{editForm.width}px</div>
                  </div>

                  <div className="mb-4">
                    <label className="block text-sm font-bold mb-2">Alto (px)</label>
                    <input
                      type="range"
                      min="20"
                      max="100"
                      value={editForm.height}
                      onChange={(e) => setEditForm({ ...editForm, height: parseInt(e.target.value) })}
                      className="w-full"
                    />
                    <div className="text-center text-gray-600">{editForm.height}px</div>
                  </div>

                  <div className="mb-4 p-4 bg-gray-100 rounded flex items-center justify-center">
                    <div
                      className={`${editingButton.sector === 'IA' ? 'bg-blue-500' : 'bg-purple-500'} text-white flex items-center justify-center font-bold rounded-lg border-2 border-white`}
                      style={{ width: `${editForm.width}px`, height: `${editForm.height}px`, fontSize: '11px' }}
                    >
                      {editingButton.name} ({editingButton.sector})
                    </div>
                  </div>

                  <div className="flex gap-2">
                    <button
                      onClick={updateButtonStyle}
                      className="flex-1 bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 font-bold flex items-center justify-center gap-2"
                    >
                      Confirmar
                    </button>
                    <button
                      onClick={() => {
                        deleteButton(editingButton.id);
                        setShowEditDialog(false);
                      }}
                      className="flex-1 bg-red-600 text-white py-3 rounded-lg hover:bg-red-700 font-bold flex items-center justify-center gap-2"
                    >
                      <Trash2 /> Eliminar
                    </button>
                    <button
                      onClick={() => {
                        setShowEditDialog(false);
                        setEditingButton(null);
                      }}
                      className="bg-gray-400 text-white px-4 py-3 rounded-lg hover:bg-gray-500 font-bold"
                    >
                      <X />
                    </button>
                  </div>
                </div>
              </div>
            );
          }

          if (view === 'heatmap') {
            const model = getCurrentModel();
            
            return (
              <div className="fixed inset-0 bg-black z-50">
                <div className="h-full flex flex-col">
                  <div className="bg-gray-900 p-4 flex justify-between items-center">
                    <h2 className="text-white text-xl font-bold">Mapa de Calor - {model.name}</h2>
                    <button
                      onClick={() => setView('inspect')}
                      className="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600 flex items-center gap-2"
                    >
                      <X /> Cerrar
                    </button>
                  </div>
                  
                  {/* CONTENEDOR DE IMAGEN CORREGIDO: overflow-auto, no flex-1 directo */}
                  <div className="flex-1 relative overflow-auto bg-gray-800">
                    {/* Elemento que contiene la imagen y los botones, para asegurar que la imagen define el tamaño */}
                    <div className="relative w-full h-full">
                      <img
                        src={model.image}
                        alt={model.name}
                        // Usamos object-contain para que la imagen se ajuste y centramos
                        className="w-full h-full object-contain" 
                        ref={imageRef} // Reutilizamos imageRef para cálculos relativos
                      />
                      
                      {/* VISTA DE INDICADORES EN EL MAPA DE CALOR */}
                      {getCurrentModelButtons().map(button => {
                        const counts = getButtonDefectCount(button.id);
                        const total = counts.total;
                        
                        // Solo mostrar indicadores si hay defectos
                        if (total === 0) return null; 

                        return (
                          <div
                            key={button.id}
                            style={{
                              position: 'absolute',
                              // Se usan los valores en % para que la posición sea relativa al tamaño de la imagen, corrigiendo el problema de movimiento.
                              left: `${button.x}%`,
                              top: `${button.y}%`,
                              transform: 'translate(-50%, -50%)',
                              pointerEvents: 'none', 
                              zIndex: 10
                            }}
                          >
                            {/* Círculo indicador de calor */}
                            <div
                              className="w-16 h-16 rounded-full flex items-center justify-center text-white font-bold text-sm border-2 border-white shadow-lg"
                              style={{ 
                                backgroundColor: getDefectColor(total),
                                animation: 'pulse 1.5s infinite' 
                              }}
                            >
                              {total}
                            </div>
                            {/* Etiqueta flotante */}
                            <div className="bg-black bg-opacity-90 text-white text-xs p-2 rounded mt-1 whitespace-nowrap text-center">
                              <div className="font-bold">{button.name} ({button.sector})</div>
                              <div className="grid grid-cols-2 text-left gap-x-2">
                                <span className="text-red-400">Faltante: {counts.faltante}</span>
                                <span className="text-orange-400">Levantado: {counts.levantado}</span>
                                <span className="text-pink-400">Mal Ins.: {counts.mal_insertado}</span>
                                <span className="text-indigo-400">Equivocado: {counts.equivocado}</span>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
                {/* Animación local para el mapa de calor */}
                <style>{`
                  @keyframes pulse {
                    0%, 100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
                    70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
                  }
                `}</style>
              </div>
            );
          }

          if (view === 'select') {
            return (
              <div className="min-h-screen bg-gradient-to-br from-blue-900 to-blue-700 p-4">
                <div className="max-w-4xl mx-auto">
                  <h1 className="text-4xl font-bold text-white mb-8 text-center">
                    Inspector de Defectos PCB
                  </h1>
                  
                  <div className="bg-white rounded-lg shadow-xl p-6 mb-6">
                    <label className="flex items-center justify-center gap-3 cursor-pointer bg-blue-600 hover:bg-blue-700 text-white py-4 px-6 rounded-lg transition">
                      <Upload />
                      <span className="text-lg font-semibold">Cargar Nueva Placa</span>
                      <input
                        type="file"
                        accept="image/jpeg,image/jpg"
                        onChange={handleImageUpload}
                        className="hidden"
                      />
                    </label>
                  </div>

                  {models.length === 0 ? (
                    <div className="bg-white bg-opacity-20 rounded-lg p-8 text-center text-white">
                      <div className="flex justify-center mb-4"><Upload /></div>
                      <h2 className="text-2xl font-bold mb-2">No hay placas cargadas</h2>
                      <p className="text-lg">Haz clic en "Cargar Nueva Placa" para comenzar</p>
                    </div>
                  ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                      {models.map(model => (
                        <div
                          key={model.id}
                          className="bg-white rounded-lg shadow-lg overflow-hidden hover:shadow-xl transition"
                        >
                          <div 
                            onClick={() => selectModel(model.id)}
                            className="cursor-pointer"
                          >
                            <img
                              src={model.image}
                              alt={model.name}
                              className="w-full h-48 object-cover"
                            />
                            <div className="p-4">
                              <h3 className="text-lg font-bold text-gray-800">{model.name}</h3>
                            </div>
                          </div>
                          <div className="px-4 pb-4">
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                if (confirm('¿Eliminar esta placa y todos sus datos?')) {
                                  setModels(models.filter(m => m.id !== model.id));
                                  setButtons(buttons.filter(b => b.modelId !== model.id));
                                  const newDefects = { ...defects };
                                  delete newDefects[model.id];
                                  setDefects(newDefects);
                                }
                              }}
                              className="text-red-600 hover:text-red-800 text-sm font-semibold"
                            >
                              <Trash2 style={{display:'inline', width:'16px', height:'16px', marginRight:'4px'}} />
                              Eliminar
                            </button>
                          </div>
                      </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        );
      }

      if (view === 'inspect') {
        const model = getCurrentModel();
        const sortedButtons = getSortedButtons();
        
        return (
          <div className="fixed inset-0 bg-black flex">
            <div 
              className={`absolute top-0 left-0 h-full bg-gray-900 transition-transform duration-300 z-40 ${showSidebar ? 'translate-x-0' : '-translate-x-full'}`}
              style={{ width: '160px' }}
            >
              <div className="bg-gray-800 p-2 flex justify-between items-center">
                <h3 className="text-white font-bold text-xs">Defectos</h3>
                <button
                  onClick={() => setShowSidebar(false)}
                  className="text-white hover:bg-gray-700 p-1 rounded"
                >
                  <X style={{width:'16px',height:'16px'}} />
                </button>
              </div>
              <div className="overflow-y-auto" style={{ height: 'calc(100% - 40px)' }}>
                {sortedButtons.map(button => {
                  const counts = getButtonDefectCount(button.id);
                  return (
                    <div
                      key={button.id}
                      className="p-2 border-b border-gray-700 hover:bg-gray-800 cursor-pointer text-white text-xs"
                      onClick={() => {
                        // En modo inspección, el clic lateral no debería cambiar el modo de edición
                        setShowSidebar(false);
                      }}
                    >
                      <div className="font-bold mb-1 truncate">{button.name} ({button.sector})</div>
                      <div className="grid grid-cols-5 gap-1 text-xs">
                        <span className="text-red-400" title="Faltante">F:{counts.faltante}</span>
                        <span className="text-orange-400" title="Levantado">L:{counts.levantado}</span>
                        <span className="text-pink-400" title="Mal Insertado">MI:{counts.mal_insertado}</span>
                        <span className="text-indigo-400" title="Equivocado">E:{counts.equivocado}</span>
                        <span className="text-yellow-400 font-bold" title="Total">T:{counts.total}</span>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            <div className="flex-1 flex flex-col">
              <div className="bg-gray-900 p-2 flex justify-between items-center flex-shrink-0">
                <div className="flex gap-2">
                  <button
                    onClick={() => setShowSidebar(!showSidebar)}
                    className="bg-gray-700 text-white px-3 py-2 rounded hover:bg-gray-600"
                  >
                    <Menu />
                  </button>
                  <button
                    onClick={() => setView('select')}
                    className="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600"
                  >
                    ← Volver
                  </button>
                </div>
                
                <div className="text-center text-white">
                    <span className="font-bold text-lg block">{model.name}</span>
                    <span className="text-xs text-gray-400">Puesto: {puesto} <span onClick={() => setShowStationDialog(true)} className="underline cursor-pointer">(Cambiar)</span></span>
                </div>
                
                <div className="flex gap-2">
                  <button
                    onClick={() => setShowAddButton(!showAddButton)}
                    className={`px-4 py-2 rounded ${showAddButton ? 'bg-green-600' : 'bg-blue-600'} text-white hover:opacity-80`}
                    title="Agregar Componente"
                  >
                    <Plus />
                  </button>
                  
                  <button
                    onClick={() => {
                      setIsEditMode(!isEditMode);
                      setShowDefectMenu(false); 
                      setShowAddButton(false);
                      setPulsingButtonId(null); 
                    }}
                    className={`px-4 py-2 rounded ${isEditMode ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-gray-700 hover:bg-gray-600'} text-white`}
                    title="Modo Edición (Mover/Ajustar Componentes)"
                  >
                    <Settings />
                  </button>
                  
                  <button
                    onClick={() => setView('heatmap')}
                    className="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700"
                    title="Mapa de Calor"
                  >
                    <BarChart3 />
                  </button>
                  <button
                    onClick={exportToExcel}
                    className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700"
                    title="Exportar a Excel"
                  >
                    <Download />
                  </button>
                </div>
              </div>

              {/* UI para CREAR COMPONENTE */}
              {showAddButton && (
                <div className="bg-green-600 p-3 flex gap-2 items-center flex-shrink-0">
                  <input
                    type="text"
                    value={newButtonName}
                    onChange={(e) => setNewButtonName(e.target.value)}
                    placeholder="Nombre (ej: C1, R5)"
                    className="px-3 py-2 rounded flex-1"
                    autoFocus
                    onKeyPress={(e) => {
                      if (e.key === 'Enter' && newButtonName.trim()) {
                        handleOpenSectorDialog();
                      }
                    }}
                  />
                  <button
                    onClick={handleOpenSectorDialog}
                    disabled={!newButtonName.trim()}
                    className={`px-4 py-2 rounded font-bold ${newButtonName.trim() ? 'bg-green-800 hover:bg-green-700' : 'bg-green-400'} text-white`}
                  >
                    Crear
                  </button>
                </div>
              )}
              
              {/* Contenedor principal para la imagen y botones */}
              {/* CORRECCIÓN: El contenedor debe ser overflow-auto y contener la imagen y botones absolutos */}
              <div 
                ref={containerRef}
                className="flex-1 relative overflow-auto bg-gray-900"
                onClick={() => showDefectMenu && setShowDefectMenu(false)}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                onContextMenu={(e) => e.preventDefault()}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleMouseUp}
              >
                {/* Elemento que contiene la imagen y los botones, para asegurar que la imagen define el tamaño */}
                <div className="relative w-full h-full">
                    <img
                        ref={imageRef}
                        src={model.image}
                        alt={model.name}
                        // Usamos object-contain para que la imagen se ajuste y centramos
                        className="w-full h-full object-contain"
                        style={{ userSelect: 'none' }}
                    />
                
                    {getCurrentModelButtons().map(button => {
                        const isBeingDragged = draggedButton === button.id;
                        const isPulsing = pulsingButtonId === button.id;
                        
                        return (
                        <div
                            key={button.id}
                            style={{
                            position: 'absolute',
                            // Se usan los valores en % para que la posición sea relativa al tamaño de la imagen.
                            left: `${button.x}%`,
                            top: `${button.y}%`,
                            transform: 'translate(-50%, -50%)',
                            pointerEvents: 'auto'
                            }}
                        >
                            <button
                            className={`text-white shadow-lg transition font-bold border-2 rounded-lg ${button.sector === 'IA' ? 'bg-blue-500' : 'bg-purple-500'} ${isBeingDragged ? 'bg-opacity-90 border-yellow-400 border-4' : 'bg-opacity-60 hover:bg-opacity-80'} ${isEditMode ? 'border-yellow-400 border-dashed border-2 cursor-grab' : 'border-white cursor-pointer'} ${isPulsing ? 'animate-pulse-new' : ''}`}
                            style={{
                                width: `${button.width || 50}px`,
                                height: `${button.height || 30}px`,
                                fontSize: '11px',
                                cursor: isEditMode ? (isBeingDragged ? 'grabbing' : 'grab') : 'pointer'
                            }}
                            onClick={(e) => handleButtonClick(button, e)}
                            onMouseDown={(e) => handleDragStart(button, e)}
                            onTouchStart={(e) => handleDragStart(button, e)}
                            >
                            {button.name} ({button.sector})
                            {isEditMode && <Settings style={{width: '12px', height: '12px', marginLeft: '4px', display: 'inline'}} />}
                            </button>
                        </div>
                        );
                    })}
                </div>
              
                {showDefectMenu && !isDragging && (
                  <DefectColumnMenu 
                    menuPosition={menuPosition} 
                    registerDefect={registerDefect} 
                    defectTypes={defectTypes}
                    containerRef={containerRef}
                  />
                )}
              </div>
            </div>
          </div>
        );
      }
      
      return null;
    };


    // COMPONENTE: Menú de Fallas en Columna
    const DefectColumnMenu = ({ menuPosition, registerDefect, defectTypes, containerRef }) => {
        const menuRef = useRef(null);
        const [adjustedStyle, setAdjustedStyle] = useState({});

        const defectItems = [
            { type: 'faltante', name: defectTypes['faltante'].name, color: defectTypes['faltante'].color },
            { type: 'levantado', name: defectTypes['levantado'].name, color: defectTypes['levantado'].color },
            { type: 'mal_insertado', name: defectTypes['mal_insertado'].name, color: defectTypes['mal_insertado'].color },
            { type: 'equivocado', name: defectTypes['equivocado'].name, color: defectTypes['equivocado'].color },
        ];
        
        // Dimensiones estimadas para el cálculo
        const BUTTON_WIDTH = 120; // Ancho de un botón de defecto
        const BUTTON_HEIGHT = 45; // Alto de un botón de defecto
        const PADDING = 10;
        const MENU_HEIGHT = (BUTTON_HEIGHT * defectItems.length) + (PADDING * (defectItems.length - 1)) + 20; // Altura total de la columna (aprox 200px)
        const BUTTON_OFFSET = 10; // Separación del componente

        useEffect(() => {
            if (!containerRef.current) return;
            
            const containerRect = containerRef.current.getBoundingClientRect();
            
            // Posición centralizada del componente clicado (en coordenadas de pantalla)
            const btnCenterY = menuPosition.y + menuPosition.height / 2;
            const btnRightX = menuPosition.x + menuPosition.width;
            const btnLeftX = menuPosition.x;

            let finalLeft = 0;
            let finalTop = 0;
            
            // 1. Determinar el lado (Derecha por defecto)
            const spaceNeededRight = BUTTON_WIDTH + BUTTON_OFFSET;
            const canFitRight = (btnRightX + spaceNeededRight) < containerRect.right;
            
            if (canFitRight) {
                finalLeft = btnRightX + BUTTON_OFFSET;
            } else {
                finalLeft = btnLeftX - BUTTON_WIDTH - BUTTON_OFFSET;
                
                if (finalLeft < containerRect.left) {
                    finalLeft = containerRect.left + PADDING; 
                }
            }

            // 2. Determinar la posición Vertical (Centrado por defecto)
            finalTop = btnCenterY - (MENU_HEIGHT / 2);

            // Ajuste para evitar que el menú se salga del borde superior
            if (finalTop < containerRect.top + PADDING) {
                finalTop = containerRect.top + PADDING;
            }

            // Ajuste para evitar que el menú se salga del borde inferior
            if (finalTop + MENU_HEIGHT > containerRect.bottom - PADDING) {
                finalTop = containerRect.bottom - MENU_HEIGHT - PADDING;
                
                if (finalTop < containerRect.top + PADDING) {
                    finalTop = containerRect.top + PADDING; 
                }
            }

            // Establecer el estilo ajustado
            setAdjustedStyle({
                left: `${finalLeft}px`,
                top: `${finalTop}px`,
                width: `${BUTTON_WIDTH}px`,
                height: `${MENU_HEIGHT}px`,
            });

        }, [menuPosition, containerRef]);


        return (
            <div
                ref={menuRef}
                className="fixed z-50 p-2 bg-gray-800 bg-opacity-90 rounded-lg shadow-2xl flex flex-col gap-2"
                style={adjustedStyle}
                // No permitir que el menú intercepte el clic del contenedor padre para cerrarse si se hace clic DENTRO del menú
                onClick={(e) => e.stopPropagation()} 
            >
                {defectItems.map((item) => (
                    <button
                        key={item.type}
                        onClick={() => registerDefect(item.type)}
                        className={`${item.color} text-white px-2 py-2 rounded-lg shadow-md hover:opacity-80 font-bold text-sm w-full h-11 transition`}
                    >
                        {item.name}
                    </button>
                ))}
            </div>
        );
    };


    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PCBDefectInspector />);
</script>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('✅ Service Worker registrado'))
                .catch(err => console.log('❌ Error al registrar SW:', err));
        });
    }
</script>
